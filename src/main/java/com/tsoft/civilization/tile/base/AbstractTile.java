package com.tsoft.civilization.tile.base;

import com.tsoft.civilization.L10n.L10nFeature;
import com.tsoft.civilization.L10n.L10nTile;
import com.tsoft.civilization.combat.HasCombatStrength;
import com.tsoft.civilization.improvement.AbstractImprovement;
import com.tsoft.civilization.tile.util.FeatureList;
import com.tsoft.civilization.tile.util.MissileTilePastCostTable;
import com.tsoft.civilization.tile.util.TileCatalog;
import com.tsoft.civilization.tile.util.TilePassCostTable;
import com.tsoft.civilization.world.economic.TileScore;
import com.tsoft.civilization.world.economic.TileSupply;
import com.tsoft.civilization.tile.feature.*;
import com.tsoft.civilization.tile.luxury.AbstractLuxury;
import com.tsoft.civilization.tile.resource.AbstractResource;
import com.tsoft.civilization.unit.AbstractUnit;
import com.tsoft.civilization.util.DefaultLogger;
import com.tsoft.civilization.util.Point;
import com.tsoft.civilization.web.view.tile.base.AbstractTileView;

import java.lang.reflect.Constructor;
import java.util.List;

public abstract class AbstractTile<V extends AbstractTileView> {
    private Point location;
    private AbstractLuxury luxury;
    private AbstractResource resource;
    private AbstractImprovement improvement;
    private FeatureList features = new FeatureList();

    public abstract TileType getTileType();
    public abstract boolean canBuildCity();

    public abstract int getDefensiveBonusPercent();

    public abstract String getClassUuid();
    public abstract V getView();

    public abstract TileSupply getBaseSupply();

    public static AbstractTile newInstance(String classUuid) {
        AbstractTile tile = getTileFromCatalogByClassUuid(classUuid);
        if (tile == null) {
            return null;
        }

        try {
            Constructor constructor = tile.getClass().getConstructor();
            tile = (AbstractTile)constructor.newInstance();

            return tile;
        } catch (Exception ex) {
            DefaultLogger.severe("Can't create an object", ex);
        }
        return null;
    }

    public static AbstractTile getTileFromCatalogByClassUuid(String classUuid) {
        for (AbstractTile tile : TileCatalog.baseTiles()) {
            if (tile.getClassUuid().equals(classUuid)) {
                return tile;
            }
        }
        return null;
    }

    public Point getLocation() {
        return location;
    }

    public void setLocation(Point location) {
        this.location = location;
    }

    public AbstractLuxury getLuxury() {
        return luxury;
    }

    public boolean setLuxury(AbstractLuxury luxury) {
        if (getResource() == null) {
            this.luxury = luxury;
            return true;
        }
        return false;
    }

    public AbstractResource getResource() {
        return resource;
    }

    public boolean setResource(AbstractResource resource) {
        if (getLuxury() == null) {
            this.resource = resource;
            return true;
        }
        return false;
    }

    public AbstractImprovement getImprovement() {
        return improvement;
    }

    public void setImprovement(AbstractImprovement improvement) {
        this.improvement = improvement;
    }

    public FeatureList getFeatures() {
        return features;
    }

    public <F extends AbstractFeature> F getFeature(Class<F> featureClass) {
        F feature = features.getByClass(featureClass);
        return feature;
    }

    public void addFeature(AbstractFeature feature) {
        features.add(feature);
    }

    public void removeFeature(AbstractFeature feature) {
        features.remove(feature);
    }

    // Don't generate events for civilization
    // They must be generated by caller
    public TileScore getSupply() {
        TileScore score = new TileScore(null);
        score.add(getBaseSupply(), L10nTile.TILE_BASE_SUPPLY);

        // add feature's supply
        if (!features.isEmpty()) {
            // start from last (i.e. on top) feature
            for (int i = features.size() - 1; i >= 0; i --) {
                AbstractFeature feature = features.get(i);

                // look for a blocking feature
                if (feature.isBlockingTileSupply()) {
                    score = new TileScore(null);
                    score.add(feature.getSupply(), L10nFeature.FEATURE_BLOCKING_SUPPLY);
                    return score;
                }

                score.add(feature.getSupply(), L10nFeature.FEATURE_ON_TILE_SUPPLY);
            }
        }
        return score;
    }

    // Returns passing cost for a unit
    public int getPassCost(AbstractUnit unit) {
        int passCost = TilePassCostTable.get(unit, this);
        if (!features.isEmpty()) {
            // start from last (i.e. on top) feature
            for (int i = features.size() - 1; i >= 0; i --) {
                AbstractFeature feature = features.get(i);
                passCost += feature.getPassCost(unit);
            }
        }
        return passCost;
    }

    // Returns passing (or flying) cost for attacker's missile
    public int getMissilePastCost(HasCombatStrength attacker) {
        int passCost = MissileTilePastCostTable.get(attacker, this);
        if (!features.isEmpty()) {
            // start from last (i.e. on top) feature
            for (int i = features.size() - 1; i >= 0; i --) {
                AbstractFeature feature = features.get(i);
                passCost += feature.getMissilePassCost(attacker);
            }
        }
        return passCost;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        AbstractTile that = (AbstractTile) o;

        if (!location.equals(that.location)) return false;

        return true;
    }

    @Override
    public int hashCode() {
        return location.hashCode();
    }

    @Override
    public String toString() {
        return getClass().getName() + " {location=" + location.toString() + '}';
    }
}
